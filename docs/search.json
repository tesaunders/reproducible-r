[
  {
    "objectID": "02_code.html",
    "href": "02_code.html",
    "title": "R Code",
    "section": "",
    "text": "We can improve our scripts by writing code which is:\n\nReadable\n\n\nUse a consistent style guide (like the tidyverse one)\nBe clear, concise, and consistent when naming objects, datasets, and functions\nBreak your scripts up into sections (Ctrl+Shift+R)\n\n\nReusable\n\n\nWrite functions to perform sets of operations\nUse iteration (for loops, or map())\nConsider creating packages for data and code used in multiple places\nBreak up long scripts into separate files (cleaning, manipulating, plotting)\n\n\nDocumented\n\n\nUse comments to explain why you did something the way you did\nInclude a README with each project to provide important context and background\n\nCreate a new script in RStudio (Ctrl+Shift+N) and save it in the scripts folder.\nLoad packages we need for the workshop.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(purrr)\nlibrary(renv)\n\nLet’s take a common example of some data analysis and apply the above principles when writing the code.\nFirst, let’s read in some data split into different files by month. Instead of naming each file, we can use readr::read_csv() to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source.\n\nfiles &lt;- list.files(path = \"data_raw\", pattern = \"\\\\.csv\", full.names = TRUE)\n\nsurveys &lt;- read_csv(files, id = \"source\")\n\nThis dataset comprises measurements taken from mammals captured in the Chihuahuan desert.\nLet’s say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we’re only interested in species codes with at least 100 valid observations, that’s still 11 plots.\n\nvalid_species &lt;-\n  surveys |&gt;\n  drop_na(all_of(c(\"weight\", \"hindfoot_length\"))) |&gt; \n  count(species_id) |&gt; \n  filter(n &gt;= 100) |&gt; \n  pull(species_id)\n\nRather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.\n\n# Create an example of a plot\nggplot(surveys, aes(x = weight, y = hindfoot_length, colour = sex)) +\n  geom_point() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nplot_species &lt;- function(data, x_var, y_var, colour, species) {\n\n  filtered_data &lt;- \n    data |&gt; \n    filter(species_id == {{ species }})\n  \n  plot_title &lt;- paste0(y_var, \" vs. \", x_var, \" for Species ID: \", species)\n  \n  plot &lt;- \n    filtered_data |&gt; \n    ggplot(aes(x = .data[[x_var]], y = .data[[y_var]], colour = .data[[colour]])) +\n    geom_point(alpha = 0.6) +\n    theme_minimal() +\n    ggtitle(plot_title)\n  \n  save_path &lt;- paste0(\"figures/\", species, \"_\", x_var, \"_vs_\", y_var, \".png\")\n  \n  ggsave(save_path, plot = plot, width = 10, height = 6, units = \"in\")\n}\n\nwalk(valid_species, ~ plot_species(\n  data = surveys,\n  x_var = \"weight\",\n  y_var = \"hindfoot_length\",\n  colour = \"sex\",\n  species = .x \n))"
  },
  {
    "objectID": "02_code.html#writing-better-code",
    "href": "02_code.html#writing-better-code",
    "title": "R Code",
    "section": "",
    "text": "We can improve our scripts by writing code which is:\n\nReadable\n\n\nUse a consistent style guide (like the tidyverse one)\nBe clear, concise, and consistent when naming objects, datasets, and functions\nBreak your scripts up into sections (Ctrl+Shift+R)\n\n\nReusable\n\n\nWrite functions to perform sets of operations\nUse iteration (for loops, or map())\nConsider creating packages for data and code used in multiple places\nBreak up long scripts into separate files (cleaning, manipulating, plotting)\n\n\nDocumented\n\n\nUse comments to explain why you did something the way you did\nInclude a README with each project to provide important context and background\n\nCreate a new script in RStudio (Ctrl+Shift+N) and save it in the scripts folder.\nLoad packages we need for the workshop.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(purrr)\nlibrary(renv)\n\nLet’s take a common example of some data analysis and apply the above principles when writing the code.\nFirst, let’s read in some data split into different files by month. Instead of naming each file, we can use readr::read_csv() to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source.\n\nfiles &lt;- list.files(path = \"data_raw\", pattern = \"\\\\.csv\", full.names = TRUE)\n\nsurveys &lt;- read_csv(files, id = \"source\")\n\nThis dataset comprises measurements taken from mammals captured in the Chihuahuan desert.\nLet’s say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we’re only interested in species codes with at least 100 valid observations, that’s still 11 plots.\n\nvalid_species &lt;-\n  surveys |&gt;\n  drop_na(all_of(c(\"weight\", \"hindfoot_length\"))) |&gt; \n  count(species_id) |&gt; \n  filter(n &gt;= 100) |&gt; \n  pull(species_id)\n\nRather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.\n\n# Create an example of a plot\nggplot(surveys, aes(x = weight, y = hindfoot_length, colour = sex)) +\n  geom_point() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nplot_species &lt;- function(data, x_var, y_var, colour, species) {\n\n  filtered_data &lt;- \n    data |&gt; \n    filter(species_id == {{ species }})\n  \n  plot_title &lt;- paste0(y_var, \" vs. \", x_var, \" for Species ID: \", species)\n  \n  plot &lt;- \n    filtered_data |&gt; \n    ggplot(aes(x = .data[[x_var]], y = .data[[y_var]], colour = .data[[colour]])) +\n    geom_point(alpha = 0.6) +\n    theme_minimal() +\n    ggtitle(plot_title)\n  \n  save_path &lt;- paste0(\"figures/\", species, \"_\", x_var, \"_vs_\", y_var, \".png\")\n  \n  ggsave(save_path, plot = plot, width = 10, height = 6, units = \"in\")\n}\n\nwalk(valid_species, ~ plot_species(\n  data = surveys,\n  x_var = \"weight\",\n  y_var = \"hindfoot_length\",\n  colour = \"sex\",\n  species = .x \n))"
  },
  {
    "objectID": "04_dependencies.html",
    "href": "04_dependencies.html",
    "title": "Managing Dependencies",
    "section": "",
    "text": "One of the benefits of using R to analyse data is gaining access to the incredible ecosystem of packages that have been developed to make it easier to perform all kinds of different analyses. Packages are often updated to fix bugs, add new functionality, or change existing functionality. Sometimes this means code breaks - something that used to work with a previous version of a package no longer works, so the code stops running. This can be frustrating and time consuming to fix. Fortunately, by smartly managing dependencies (the packages that our code depends on to work), we can largely avoid the problem."
  },
  {
    "objectID": "04_dependencies.html#introducing-renv",
    "href": "04_dependencies.html#introducing-renv",
    "title": "Managing Dependencies",
    "section": "Introducing renv",
    "text": "Introducing renv\nrenv (short for r environment) makes your R projects:\n\nIsolated: Installing a new or updated package for one project won’t break your other projects, and vice versa. That’s because renv gives each project its own private package library.\nPortable: Easily transport your projects from one computer to another, even across different platforms. renv makes it easy to install the packages your project depends on.\nReproducible: renv records the exact package versions you depend on, and ensures those exact versions are the ones that get installed wherever the project goes.\n\nrenv can be installed onto your machine like any other package at any time during the lifecycle of your project. In the console:\n\ninstall.packages(\"renv\")\n\nTo use renv in your project, in the console:\n\nrenv::init()\n\nThis will set up a project library in a folder called renv, containing all the packages you’re currently using. The packages (and all the metadata needed to reinstall them) are recorded into a lockfile, renv.lock, and a .Rprofile file ensures that the library is used every time you open that project.\nAs you work on your project, you will install and upgrade packages, either using install.packages() and update.packages() or renv::install() and renv::update(). After you’ve confirmed your code works as expected, use renv::snapshot() to record the packages and their sources in an updated lockfile.\nLater, if you need to share your code with someone else or run your code on new machine, your collaborator (or you) can call renv::restore() to install the specific package versions recorded in the lockfile.\nWhen we use renv commands we use the :: notation so we don’t actually have to load the renv package, and we always enter renv commands in the console. We don’t preserve them in our script.\nThe below graphic shows a diagram of the standard workflow:"
  },
  {
    "objectID": "04_dependencies.html#testing-it-out",
    "href": "04_dependencies.html#testing-it-out",
    "title": "Managing Dependencies",
    "section": "Testing it out",
    "text": "Testing it out\nRun renv::init() and you should see some activity in the console and you’ll see some new files in the Git pane.\nWe now have a renv.lock file that has recorded the packages, and their versions, that are loaded in our script (or loaded in any scripts within our project).\nLets install and load another package, as if we were going to use it in our script. In the console:\n\ninstall.packages(\"ratdat\")\n\nrenv should tell you in the console that it is going to download the package from CRAN and install it within the project/renv folder. You’ll need to hit Shift+Y to confirm. It downloads the package, installs it first into your general R package library, then moves a copy into the project/renv folder. Now let’s load it in our script as if we were going to use it.\n\nlibrary(\"ratdat\")\n\nLet’s pretend we used the package and were happy with our code. We can check the status of our project to see if renv has detected the new package.\n\nrenv::status()\n\nrenv should tell you that ratdat is installed and used, but not recorded in the lock file. To fix this we take a snapshot to update the lock file.\n\nrenv::snapshot()\n\nYou should be prompted to allow the lock file to be updated with the package (Shift+Y to confirm).\nAs we’re not actually using this package, we can remove it from our project by running:\n\nrenv::remove(\"ratdat\")\n\nAnd deleting the library(\"ratdat) call above. Now we can update our lock file again:\n\nrenv::snapshot()\n\nIf someone clones the project from GitHub, and they have renv installed, they can renv::restore() the packages within the lockfile so that these package versions will be installed into the project package library on their machine too. This means they have the same packages, and the same versions, installed in their project library as the person who created the code."
  }
]