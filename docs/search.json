[
  {
    "objectID": "02_code.html",
    "href": "02_code.html",
    "title": "R Code",
    "section": "",
    "text": "We can improve our scripts by writing code which is:\n\nReadable\n\n\nUse a consistent style guide (like the tidyverse one)\nBe clear, concise, and consistent when naming objects, datasets, and functions\nBreak your scripts up into sections (Ctrl+Shift+R)\n\n\nReusable\n\n\nWrite functions to perform sets of operations\nUse iteration (for loops, or map())\nConsider creating packages for data and code used in multiple places\nBreak up long scripts into separate files (cleaning, manipulating, plotting)\n\n\nDocumented\n\n\nUse comments to explain why you did something the way you did\nInclude a README with each project to provide important context and background\n\nCreate a new script in RStudio (Ctrl+Shift+N) and save it in the scripts folder.\nLoad packages we need for the workshop.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(purrr)\nlibrary(renv)\n\nLet’s take a common example of some data analysis and apply the above principles when writing the code.\nFirst, let’s read in some data split into different files by month. Instead of naming each file, we can use readr::read_csv() to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source.\n\nfiles &lt;- list.files(path = \"data_raw\", pattern = \"\\\\.csv\", full.names = TRUE)\n\nsurveys &lt;- read_csv(files, id = \"source\")\n\nThis dataset comprises measurements taken from mammals captured in the Chihuahuan desert.\nLet’s say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we’re only interested in species codes with at least 100 valid observations, that’s still 11 plots.\n\nvalid_species &lt;-\n  surveys |&gt;\n  drop_na(all_of(c(\"weight\", \"hindfoot_length\"))) |&gt; \n  count(species_id) |&gt; \n  filter(n &gt;= 100) |&gt; \n  pull(species_id)\n\nRather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.\n\n# Create an example of a plot\nggplot(surveys, aes(x = weight, y = hindfoot_length, colour = sex)) +\n  geom_point() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nplot_species &lt;- function(data, x_var, y_var, colour, species) {\n\n  filtered_data &lt;- \n    data |&gt; \n    filter(species_id == {{ species }})\n  \n  plot_title &lt;- paste0(y_var, \" vs. \", x_var, \" for Species ID: \", species)\n  \n  plot &lt;- \n    filtered_data |&gt; \n    ggplot(aes(x = .data[[x_var]], y = .data[[y_var]], colour = .data[[colour]])) +\n    geom_point(alpha = 0.6) +\n    theme_minimal() +\n    ggtitle(plot_title)\n  \n  save_path &lt;- paste0(\"figures/\", species, \"_\", x_var, \"_vs_\", y_var, \".png\")\n  \n  ggsave(save_path, plot = plot, width = 10, height = 6, units = \"in\")\n}\n\nwalk(valid_species, ~ plot_species(\n  data = surveys,\n  x_var = \"weight\",\n  y_var = \"hindfoot_length\",\n  colour = \"sex\",\n  species = .x \n))"
  },
  {
    "objectID": "02_code.html#writing-better-code",
    "href": "02_code.html#writing-better-code",
    "title": "R Code",
    "section": "",
    "text": "We can improve our scripts by writing code which is:\n\nReadable\n\n\nUse a consistent style guide (like the tidyverse one)\nBe clear, concise, and consistent when naming objects, datasets, and functions\nBreak your scripts up into sections (Ctrl+Shift+R)\n\n\nReusable\n\n\nWrite functions to perform sets of operations\nUse iteration (for loops, or map())\nConsider creating packages for data and code used in multiple places\nBreak up long scripts into separate files (cleaning, manipulating, plotting)\n\n\nDocumented\n\n\nUse comments to explain why you did something the way you did\nInclude a README with each project to provide important context and background\n\nCreate a new script in RStudio (Ctrl+Shift+N) and save it in the scripts folder.\nLoad packages we need for the workshop.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(purrr)\nlibrary(renv)\n\nLet’s take a common example of some data analysis and apply the above principles when writing the code.\nFirst, let’s read in some data split into different files by month. Instead of naming each file, we can use readr::read_csv() to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source.\n\nfiles &lt;- list.files(path = \"data_raw\", pattern = \"\\\\.csv\", full.names = TRUE)\n\nsurveys &lt;- read_csv(files, id = \"source\")\n\nThis dataset comprises measurements taken from mammals captured in the Chihuahuan desert.\nLet’s say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we’re only interested in species codes with at least 100 valid observations, that’s still 11 plots.\n\nvalid_species &lt;-\n  surveys |&gt;\n  drop_na(all_of(c(\"weight\", \"hindfoot_length\"))) |&gt; \n  count(species_id) |&gt; \n  filter(n &gt;= 100) |&gt; \n  pull(species_id)\n\nRather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.\n\n# Create an example of a plot\nggplot(surveys, aes(x = weight, y = hindfoot_length, colour = sex)) +\n  geom_point() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nplot_species &lt;- function(data, x_var, y_var, colour, species) {\n\n  filtered_data &lt;- \n    data |&gt; \n    filter(species_id == {{ species }})\n  \n  plot_title &lt;- paste0(y_var, \" vs. \", x_var, \" for Species ID: \", species)\n  \n  plot &lt;- \n    filtered_data |&gt; \n    ggplot(aes(x = .data[[x_var]], y = .data[[y_var]], colour = .data[[colour]])) +\n    geom_point(alpha = 0.6) +\n    theme_minimal() +\n    ggtitle(plot_title)\n  \n  save_path &lt;- paste0(\"figures/\", species, \"_\", x_var, \"_vs_\", y_var, \".png\")\n  \n  ggsave(save_path, plot = plot, width = 10, height = 6, units = \"in\")\n}\n\nwalk(valid_species, ~ plot_species(\n  data = surveys,\n  x_var = \"weight\",\n  y_var = \"hindfoot_length\",\n  colour = \"sex\",\n  species = .x \n))"
  },
  {
    "objectID": "04_dependencies.html",
    "href": "04_dependencies.html",
    "title": "Managing Dependencies",
    "section": "",
    "text": "One of the benefits of using R to analyse data is gaining access to the incredible ecosystem of packages that have been developed to make it easier to perform all kinds of different analyses. Packages are often updated to fix bugs, add new functionality, or change existing functionality. Sometimes this means code breaks - something that used to work with a previous version of a package no longer works, so the code stops running. This can be frustrating and time consuming to fix. Fortunately, by smartly managing dependencies (the packages that our code depends on to work), we can largely avoid the problem."
  },
  {
    "objectID": "04_dependencies.html#introducing-renv",
    "href": "04_dependencies.html#introducing-renv",
    "title": "Managing Dependencies",
    "section": "Introducing renv",
    "text": "Introducing renv\nrenv (short for r environment) makes your R projects:\n\nIsolated: Installing a new or updated package for one project won’t break your other projects, and vice versa. That’s because renv gives each project its own private package library.\nPortable: Easily transport your projects from one computer to another, even across different platforms. renv makes it easy to install the packages your project depends on.\nReproducible: renv records the exact package versions you depend on, and ensures those exact versions are the ones that get installed wherever the project goes.\n\nrenv can be installed onto your machine like any other package at any time during the lifecycle of your project. In the console:\n\ninstall.packages(\"renv\")\n\nTo use renv in your project, in the console:\n\nrenv::init()\n\nThis will set up a project library in a folder called renv, containing all the packages you’re currently using. The packages (and all the metadata needed to reinstall them) are recorded into a lockfile, renv.lock, and a .Rprofile file ensures that the library is used every time you open that project.\nAs you work on your project, you will install and upgrade packages, either using install.packages() and update.packages() or renv::install() and renv::update(). After you’ve confirmed your code works as expected, use renv::snapshot() to record the packages and their sources in an updated lockfile.\nLater, if you need to share your code with someone else or run your code on new machine, your collaborator (or you) can call renv::restore() to install the specific package versions recorded in the lockfile.\nWhen we use renv commands we use the :: notation so we don’t actually have to load the renv package, and we always enter renv commands in the console. We don’t preserve them in our script.\nThe below graphic shows a diagram of the standard workflow:"
  },
  {
    "objectID": "04_dependencies.html#testing-it-out",
    "href": "04_dependencies.html#testing-it-out",
    "title": "Managing Dependencies",
    "section": "Testing it out",
    "text": "Testing it out\nRun renv::init() and you should see some activity in the console and you’ll see some new files in the Git pane.\nWe now have a renv.lock file that has recorded the packages, and their versions, that are loaded in our script (or loaded in any scripts within our project).\nLets install and load another package, as if we were going to use it in our script. In the console:\n\ninstall.packages(\"ratdat\")\n\nrenv should tell you in the console that it is going to download the package from CRAN and install it within the project/renv folder. You’ll need to hit Shift+Y to confirm. It downloads the package, installs it first into your general R package library, then moves a copy into the project/renv folder. Now let’s load it in our script as if we were going to use it.\n\nlibrary(\"ratdat\")\n\nLet’s pretend we used the package and were happy with our code. We can check the status of our project to see if renv has detected the new package.\n\nrenv::status()\n\nrenv should tell you that ratdat is installed and used, but not recorded in the lock file. To fix this we take a snapshot to update the lock file.\n\nrenv::snapshot()\n\nYou should be prompted to allow the lock file to be updated with the package (Shift+Y to confirm).\nAs we’re not actually using this package, we can remove it from our project by running:\n\nrenv::remove(\"ratdat\")\n\nAnd deleting the library(\"ratdat) call above. Now we can update our lock file again:\n\nrenv::snapshot()\n\nIf someone clones the project from GitHub, and they have renv installed, they can renv::restore() the packages within the lockfile so that these package versions will be installed into the project package library on their machine too. This means they have the same packages, and the same versions, installed in their project library as the person who created the code."
  },
  {
    "objectID": "01_projects.html",
    "href": "01_projects.html",
    "title": "RStudio Projects",
    "section": "",
    "text": "To allow Git to work properly with RStudio, and to ensure your local Git install is linked with your GitHub account, we need to open Git bash (windows) or Terminal (macOS) and enter:\ngit config --global user.name \"Jane Doe\"\ngit config --global user.email \"jane@example.com\"\nsubstituting your name and the email associated with your GitHub account. The user.name you give does not have to be the same as your GitHub username. It can be your actual first and last name."
  },
  {
    "objectID": "01_projects.html#final-set-up",
    "href": "01_projects.html#final-set-up",
    "title": "RStudio Projects",
    "section": "",
    "text": "To allow Git to work properly with RStudio, and to ensure your local Git install is linked with your GitHub account, we need to open Git bash (windows) or Terminal (macOS) and enter:\ngit config --global user.name \"Jane Doe\"\ngit config --global user.email \"jane@example.com\"\nsubstituting your name and the email associated with your GitHub account. The user.name you give does not have to be the same as your GitHub username. It can be your actual first and last name."
  },
  {
    "objectID": "01_projects.html#generate-a-personal-access-token",
    "href": "01_projects.html#generate-a-personal-access-token",
    "title": "RStudio Projects",
    "section": "Generate a personal access token",
    "text": "Generate a personal access token\nLog into your GitHub account. Select your profile picture in the top right corner and select ‘settings’. Scroll to the bottom of the menu bar on the left and select ‘&lt;&gt; Developer settings’-&gt; ‘Personal access tokens’ -&gt; ‘Tokens (classic)’.\nFrom here, select ‘Generate new token’ -&gt; ‘Generate new token (classic)’.\nUnder ‘Note’ give your token a name so that you can remember what it is used for. For example tom-work-laptop. You can then set an expiration date.\nIf you would like to use the same token forever, so that you don’t have to return to GitHub to generate a new token, give it a somewhat generic name and set the expiration date to No Expiration.\nFor the ‘scopes’, we recommend selecting ‘repo’, ‘workflow’ and ‘user’. There are several reasons why you would want to create different personal access tokens, but scopes are one important reason. These define what type of access you need. ‘Fine-grained tokens’ take this even further by allowing you to specify different access types for different repositories."
  },
  {
    "objectID": "01_projects.html#create-github-repository-rstudio-project",
    "href": "01_projects.html#create-github-repository-rstudio-project",
    "title": "RStudio Projects",
    "section": "Create GitHub repository & RStudio project",
    "text": "Create GitHub repository & RStudio project\nWe’re going to work in an RStudio project connected to a GitHub repository.\nFirst we create the repository in GitHub:\n\nGo to github.com, sign in, then click the green ‘New’ button.\nName it “r-data-science”, leave the rest as default, then click ‘create repository’.\nCopy the github.com address in the ‘Quick set up box’.\nOpen RStudio and select File -&gt; New project -&gt; Version control -&gt; Git -&gt; and paste the address into the ‘Repository URL’ box.\n\nIn the box called ‘Create project as subdirectory of:’ you need to select a location on your machine. It’s a good idea to create a folder called something like ‘projects’ in your user folder and select this every time, to group your repositories together in the same place on your machine(s). Let’s do that by clicking ‘Browse’, navigating to your user folder, and creating a new folder called ‘projects’ before selecting it and clicking ‘create project’.\nRStudio opens a new project called r-data-science. RStudio projects are essentially the .RProj file - this file tells RStudio that this folder is home to the project, and to use the folder as the ‘working directory’, or the place where R is looking when you ask it to load data or save an output."
  },
  {
    "objectID": "01_projects.html#set-up-folders",
    "href": "01_projects.html#set-up-folders",
    "title": "RStudio Projects",
    "section": "Set up folders",
    "text": "Set up folders\nCreate the following folders from within RStudio:\n\ndata_raw: holds the raw, untouched data.\ndata: holds cleaned data.\nresults: holds outputs like figures or summarised data.\nsrc: holds analysis script(s).\n\nThere are many ways of setting up project folders, but the idea is to pick a convention and stick to it across different projects to stay organised and save time.\nDownload this dataset and put it into data_raw.\nCreate a new R script (Ctrl+Shift+N), call it analysis.R and save it in src."
  },
  {
    "objectID": "01_projects.html#committing-with-git",
    "href": "01_projects.html#committing-with-git",
    "title": "R Code",
    "section": "Committing with Git",
    "text": "Committing with Git\nNow that we’ve set up our project folder, it’s a good time to make our first ‘commit’ to Git.\nSelect the Git tab in RStudio and tick the ‘staged’ box for the file you wish to commit. Type a commit message detailing any changes you have made and select the ‘Commit’ button.\nYou may now be presented with a pop-up asking you to connect to Github. Here you will need to paste in your github token.\nYou can now ‘push’ your commit up to GitHub, so that the GitHub repository reflects the current state of the repository on your machine."
  },
  {
    "objectID": "01_projects.html#writing-better-code",
    "href": "01_projects.html#writing-better-code",
    "title": "R Code",
    "section": "Writing better code",
    "text": "Writing better code\nWe can improve our scripts by writing code which is:\n\nReadable\n\n\nUse a consistent style guide (like the tidyverse one)\nBe clear, concise, and consistent when naming objects, datasets, and functions\nBreak your scripts up into sections (Ctrl+Shift+R)\n\n\nReusable\n\n\nWrite functions to perform sets of operations\nUse iteration (for loops, or map())\nConsider creating packages for data and code used in multiple places\nBreak up long scripts into separate files (cleaning, manipulating, plotting)\n\n\nDocumented\n\n\nUse comments to explain why you did something the way you did\nInclude a README with each project to provide important context and background\n\nCreate a new script in RStudio (Ctrl+Shift+N) and save it in the scripts folder.\nLoad packages we need for the workshop.\n#| message: false\n#| warning: false\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(purrr)\nlibrary(renv)\nLet’s take a common example of some data analysis and apply the above principles when writing the code.\nFirst, let’s read in some data split into different files by month. Instead of naming each file, we can use readr::read_csv() to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source.\n#| message: false\nfiles &lt;- list.files(path = \"data_raw\", pattern = \"\\\\.csv\", full.names = TRUE)\n\nsurveys &lt;- read_csv(files, id = \"source\")\nThis dataset comprises measurements taken from mammals captured in the Chihuahuan desert.\nLet’s say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we’re only interested in species codes with at least 100 valid observations, that’s still 11 plots.\nvalid_species &lt;-\n  surveys |&gt;\n  drop_na(all_of(c(\"weight\", \"hindfoot_length\"))) |&gt; \n  count(species_id) |&gt; \n  filter(n &gt;= 100) |&gt; \n  pull(species_id)\nRather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.\n#| message: false\n#| warning: false\n# Create an example of a plot\nggplot(surveys, aes(x = weight, y = hindfoot_length, colour = sex)) +\n  geom_point() +\n  theme_minimal()\n#| warning: false\nplot_species &lt;- function(data, x_var, y_var, colour, species) {\n\n  filtered_data &lt;- \n    data |&gt; \n    filter(species_id == {{ species }})\n  \n  plot_title &lt;- paste0(y_var, \" vs. \", x_var, \" for Species ID: \", species)\n  \n  plot &lt;- \n    filtered_data |&gt; \n    ggplot(aes(x = .data[[x_var]], y = .data[[y_var]], colour = .data[[colour]])) +\n    geom_point(alpha = 0.6) +\n    theme_minimal() +\n    ggtitle(plot_title)\n  \n  save_path &lt;- paste0(\"figures/\", species, \"_\", x_var, \"_vs_\", y_var, \".png\")\n  \n  ggsave(save_path, plot = plot, width = 10, height = 6, units = \"in\")\n}\n\nwalk(valid_species, ~ plot_species(\n  data = surveys,\n  x_var = \"weight\",\n  y_var = \"hindfoot_length\",\n  colour = \"sex\",\n  species = .x \n))"
  },
  {
    "objectID": "02_version-control.html",
    "href": "02_version-control.html",
    "title": "Version Control",
    "section": "",
    "text": "When working on your own projects, or collaborating with others, you’re likely to run into several problems:\nUsing a proper version control system solves these problems and makes collaborating on plain text documents like code much cleaner and simpler. We’ll be using Git (installed locally on our machines) alongside GitHub (a cloud service) to demo a simple collaborative workflow."
  },
  {
    "objectID": "02_version-control.html#committing-with-git",
    "href": "02_version-control.html#committing-with-git",
    "title": "Version Control",
    "section": "Committing with Git",
    "text": "Committing with Git\nNow that we’ve set up our project folder, it’s a good time to make our first ‘commit’ to Git.\nSelect the Git tab in RStudio and tick the ‘staged’ box for the file you wish to commit. Type a commit message detailing any changes you have made and select the ‘Commit’ button.\nYou may now be presented with a pop-up asking you to connect to Github. Here you will need to paste in your github token.\nYou can now ‘push’ your commit up to GitHub, so that the GitHub repository reflects the current state of the repository on your machine."
  },
  {
    "objectID": "03_code.html",
    "href": "03_code.html",
    "title": "R Code",
    "section": "",
    "text": "We can improve our scripts by writing code which is:\n\nReadable\n\n\nUse a consistent style guide (like the tidyverse one)\nBe clear, concise, and consistent when naming objects, datasets, and functions\nBreak your scripts up into sections (Ctrl+Shift+R)\n\n\nReusable\n\n\nWrite functions to perform sets of operations\nUse iteration (for loops, or map())\nConsider creating packages for data and code used in multiple places\nBreak up long scripts into separate files (cleaning, manipulating, plotting)\n\n\nDocumented\n\n\nUse comments to explain why you did something the way you did\nInclude a README with each project to provide important context and background\n\nLet’s take a common example of some data analysis and apply the above principles when writing the code. First make sure our packages are loaded:\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(purrr)\n\nLet’s read in some data split into different files by month. Instead of naming each file, we can use readr::read_csv() to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source.\n\nfiles &lt;- list.files(path = \"data_raw\", pattern = \"\\\\.csv\", full.names = TRUE)\n\nsurveys &lt;- read_csv(files, id = \"source\")\n\nThis dataset comprises measurements taken from mammals captured in the Chihuahuan desert.\nLet’s say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we’re only interested in species codes with at least 100 valid observations, that’s still 11 plots.\n\nvalid_species &lt;-\n  surveys |&gt;\n  drop_na(all_of(c(\"weight\", \"hindfoot_length\"))) |&gt; \n  count(species_id) |&gt; \n  filter(n &gt;= 100) |&gt; \n  pull(species_id)\n\nRather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.\n\n# Create an example of a plot\nggplot(surveys, aes(x = weight, y = hindfoot_length, colour = sex)) +\n  geom_point() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nplot_species &lt;- function(data, x_var, y_var, colour, species) {\n\n  filtered_data &lt;- \n    data |&gt; \n    filter(species_id == {{ species }})\n  \n  plot_title &lt;- paste0(y_var, \" vs. \", x_var, \" for Species ID: \", species)\n  \n  plot &lt;- \n    filtered_data |&gt; \n    ggplot(aes(x = .data[[x_var]], y = .data[[y_var]], colour = .data[[colour]])) +\n    geom_point(alpha = 0.6) +\n    theme_minimal() +\n    ggtitle(plot_title)\n  \n  save_path &lt;- paste0(\"figures/\", species, \"_\", x_var, \"_vs_\", y_var, \".png\")\n  \n  ggsave(save_path, plot = plot, width = 10, height = 6, units = \"in\")\n}\n\nwalk(valid_species, ~ plot_species(\n  data = surveys,\n  x_var = \"weight\",\n  y_var = \"hindfoot_length\",\n  colour = \"sex\",\n  species = .x \n))"
  },
  {
    "objectID": "03_code.html#writing-better-code",
    "href": "03_code.html#writing-better-code",
    "title": "R Code",
    "section": "",
    "text": "We can improve our scripts by writing code which is:\n\nReadable\n\n\nUse a consistent style guide (like the tidyverse one)\nBe clear, concise, and consistent when naming objects, datasets, and functions\nBreak your scripts up into sections (Ctrl+Shift+R)\n\n\nReusable\n\n\nWrite functions to perform sets of operations\nUse iteration (for loops, or map())\nConsider creating packages for data and code used in multiple places\nBreak up long scripts into separate files (cleaning, manipulating, plotting)\n\n\nDocumented\n\n\nUse comments to explain why you did something the way you did\nInclude a README with each project to provide important context and background\n\nLet’s take a common example of some data analysis and apply the above principles when writing the code. First make sure our packages are loaded:\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(purrr)\n\nLet’s read in some data split into different files by month. Instead of naming each file, we can use readr::read_csv() to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source.\n\nfiles &lt;- list.files(path = \"data_raw\", pattern = \"\\\\.csv\", full.names = TRUE)\n\nsurveys &lt;- read_csv(files, id = \"source\")\n\nThis dataset comprises measurements taken from mammals captured in the Chihuahuan desert.\nLet’s say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we’re only interested in species codes with at least 100 valid observations, that’s still 11 plots.\n\nvalid_species &lt;-\n  surveys |&gt;\n  drop_na(all_of(c(\"weight\", \"hindfoot_length\"))) |&gt; \n  count(species_id) |&gt; \n  filter(n &gt;= 100) |&gt; \n  pull(species_id)\n\nRather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.\n\n# Create an example of a plot\nggplot(surveys, aes(x = weight, y = hindfoot_length, colour = sex)) +\n  geom_point() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nplot_species &lt;- function(data, x_var, y_var, colour, species) {\n\n  filtered_data &lt;- \n    data |&gt; \n    filter(species_id == {{ species }})\n  \n  plot_title &lt;- paste0(y_var, \" vs. \", x_var, \" for Species ID: \", species)\n  \n  plot &lt;- \n    filtered_data |&gt; \n    ggplot(aes(x = .data[[x_var]], y = .data[[y_var]], colour = .data[[colour]])) +\n    geom_point(alpha = 0.6) +\n    theme_minimal() +\n    ggtitle(plot_title)\n  \n  save_path &lt;- paste0(\"figures/\", species, \"_\", x_var, \"_vs_\", y_var, \".png\")\n  \n  ggsave(save_path, plot = plot, width = 10, height = 6, units = \"in\")\n}\n\nwalk(valid_species, ~ plot_species(\n  data = surveys,\n  x_var = \"weight\",\n  y_var = \"hindfoot_length\",\n  colour = \"sex\",\n  species = .x \n))"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Online workshop lesson\nR for Data Science\nTidy data\nrenv documentation"
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Set Up",
    "section": "",
    "text": "1. Install R (or update)\nIf using a device managed by your organisation, install R from your organisational software repository or contact your IT department for help.\nTo download and install R on a personal machine:\n\nWindows: Select ‘base’, then ‘Download R for Windows’. Run the installer\nMac:\nLinux\n\n\n\n2. Install RStudio (or update)\nIf using a device managed by your organisation, install RStudio from your organisational software repository or contact your IT department for help.\nTo download and install RStudio on a personal machine (requires administrator privileges):\n\nGo here and click ‘Download RStudio Desktop’ underneath ‘2: Install RStudio’, or scroll down and select the appropriate version for your operating system.\n\n\n\n3. Install R packages\nOpen RStudio and install the following R packages by:\n\nSelecting Tools &gt; Install Packages &gt; and entering readr, readxl, dplyr, ggplot2, renv and select ‘Install’.\n\nOR\n\nRunning the following command in the console:\n\n\ninstall.packages(c(\"readr\", \"dplyr\", \"tidyr\", \"ggplot2\", \"purrr\", \"renv\"))\n\n\n\n4. Install Git\nInstall Git on Windows:\n\nDownload and install Git for Windows.\nDuring installation, when asked about “Adjusting your PATH environment”, make sure to select “Git from the command line and also from 3rd-party software”. Otherwise, accept the default options.\n\nInstall Git on Mac:\n\nOpen the Terminal app, type git --version and press Enter/Return.\nIf it’s not installed already, follow the instructions to Install the “command line developer tools”.\nDo not click “Get Xcode” - it will take too long and is not necessary for our Git lesson.\n\nInstall Git on Linux:\n\nIf Git is not already available, install it via your package manager.\nFor Debian/Ubuntu run sudo apt-get install git and for Fedora run sudo dnf install git.\n\n\n\n5. Create a GitHub account\nGo to github.com and create a free account. If you use your organisational email address you may be eligible for a free upgrade to GitHub Education. If you would like to remain anonymous, choose an appropriate username and see these instructions for keeping your email address private."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Reproducible & Collaborative Data Science with R",
    "section": "",
    "text": "Dr Tom Saunders & Dr Toby Johnson\nCentre for eResearch\nUniversity of Auckland\nWelcome to the workshop repository for Reproducible & Collaborative Data Science with R.\n\nGetting Set Up\nFollow the instructions on the set up page to install some software and create a GitHub account before the workshop.\n\n\nObjectives\nThe primary objective of this workshop is to equip emerging researchers with practical skills to unlock the potential of their R scripts by making their code reproducible, shareable, and citable.\nMost R users do not have a background in computer science or software development, but instead come with expertise from particular research domains. This presents an opportunity to empower researchers to apply software development principles to the code they write to ensure their work has maximum impact. We will cover the following concepts in this workshop:\n\nOrganising work in projects\nWriting readable and modular R code\nCollaborating with version control\nManaging package dependencies\nPublishing software projects\n\nEach of these topics alone could easily fill a 1.5 hour workshop, so our treatment of them will necessarily be brief. But our main aim here is to introduce these concepts, show how they are used together, and walk through how to start applying them to your research projects."
  }
]