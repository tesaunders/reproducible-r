---
title: "R Code"
---

## Writing better code

We can improve our scripts by writing code which is:

1. Readable

- Use a consistent style guide (like the tidyverse one)
- Be clear, concise, and consistent when naming objects, datasets, and functions
- Break your scripts up into sections (Ctrl+Shift+R)

2. Reusable

- Write functions to perform sets of operations
- Use iteration (for loops, or `map()`) 
- Consider creating packages for data and code used in multiple places
- Break up long scripts into separate files (cleaning, manipulating, plotting)

3. Documented

- Use comments to explain why you did something the way you did 
- Include a README with each project to provide important context and background

Let's take a common example of some data analysis and apply the above principles when writing the code. First load the packages we need:

```{r}
#| message: false
#| warning: false
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)
library(car)
```

Let's read in a dataset split into separate files. Instead of reading in each file separately, we can use `readr::read_csv()` to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source. The dataset we're working with contains measurements taken from mammals captured in the Chihuahuan desert. It is split into 4 separate `.csv` files based on time periods the measurements were recorded within. 

```{r}
#| message: false

# Combine data from different collection periods

files <- list.files(path = "data_raw", 
                    pattern = "\\.csv", 
                    full.names = TRUE)

surveys <- read_csv(files, id = "source")
```

Let's take a quick look at the mean `hindfoot_length` and `weight` for each species.

```{r}
#| message: false
#| warning: false
surveys |> 
  group_by(species_id) |> 
  summarise(across(c(hindfoot_length, weight), mean, na.rm = TRUE)) |> 
  na.omit()
```

To understand how `hindfoot_length` varies based on the plot type the animal was captured in let's use a boxplot.

```{r}
#| warning: false
ggplot(data = surveys, aes(x = plot_type, y = hindfoot_length)) +
  geom_boxplot() +
  theme_bw() +
  coord_flip() # Rotate the plot so the labels are easily readable
```

Let's say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we're only interested in species codes with at least 100 valid observations, that's still 11 plots.

```{r}
valid_species <-
  surveys |>
  drop_na(all_of(c("weight", "hindfoot_length"))) |> 
  count(species_id) |> 
  filter(n >= 100) |> 
  pull(species_id)
```

Let's first create a basic plot to show what we're trying to produce.

```{r}
#| message: false
#| warning: false
# Create an example of a plot

ggplot(surveys, aes(x = weight, y = hindfoot_length)) +
  geom_point(alpha = 0.2) +
  theme_minimal()
```

Rather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.

```{r}
#| warning: false
plot_species <- function(data, x_var, y_var, species) {
  
  # Useful to ensure any directories exist, or if not, create them
  if (!dir.exists("figures")) {
    dir.create("figures")
  }
  
  # Capture the variable names as strings for the filenames
  x_name <- as_label(enquo(x_var))
  y_name <- as_label(enquo(y_var))
  
  # Create the plot
  plots <- 
    data |> 
    filter(species_id == {{ species }}) |>
    ggplot(aes(x = {{ x_var }}, 
               y = {{ y_var }})) +
    geom_point(alpha = 0.2) +
    labs(title = paste("Species:", species)) +
    theme_minimal()
  
  # Construct the filename and save
  file_path <- paste0("figures/", species, "_", x_name, "_", y_name, ".png")
  
  ggsave(filename = file_path, plot = plots, width = 6, height = 4)
}

# purrr::walk iterates over a list or vector with a function

walk(valid_species, ~ plot_species(
  data = surveys,
  x_var = weight,            
  y_var = hindfoot_length,   
  species = .x 
))
```

In 1977, 24 experimental plots were established and each plot was manipulated in one of five ways. We can look at these plot types using `dplyr::distinct()` 

```{r}
surveys |> distinct(plot_type)
```

One question we may have is how this impacts the mammals captured in these areas. 

Let's look at plot_type to see how hindfoot_length differs.

```{r}
#| warning: false
ggplot(surveys, aes(x = plot_type, y = hindfoot_length)) +
  geom_boxplot() +
  theme_minimal() +
  coord_flip() 
```
There may be a relationship between hindfoot_length and plot type. 

We have a continuous dependent variable (hindfoot_length) and a categorical independent variable (plot_type), with multiple levels. An ANOVA would be an appropriate statistical test here, complemented by some post-hoc comparisons to test the individual differences in hindfoot_length across each plot_type.

First we have to check assumptions:

1. Normality

As with any general linear model we need to check that the data conforms to a normal distribution. 

We can do this graphically or statistically. To do it graphically we plot the residuals in a histogram or QQ-plot, and to do it statistically we would use a Shapiro-Wilk test, but these tests can be quite conservativegiven large sample sizes. 

Here we'll plot the residuals using a histogram and QQ-plot.

```{r}
# Run the ANOVA to get our residuals
residuals_anova <- aov(hindfoot_length ~ plot_type, data = surveys)

# Create plot space
par(mfrow = c(1, 2))

# Create histogram
hist(residuals_anova$residuals)

# Create QQ-plot
qqPlot(residuals_anova$residuals, id = FALSE)
```

The residuals do not follow a normal distribution, but in this case, combined with our large sample size our ANOVA will be fairly robust to any violation of normality.

2. Homogeneity - Equality of Variances

We also need to check whether the variance in hindfoot_length is roughly equal across all plot types. We can do this, again, using statistical methods, graphical methods, or both. Let's use a boxplot.

```{r}
#| warning: false
ggplot(surveys, aes(x = plot_type, y = hindfoot_length)) +
  geom_boxplot(outliers = FALSE) +
  theme_minimal() +
  coord_flip() # Using coord flip to rotate the plot so the labels are easily readable
```
This assumption has been violated. Having removed the outliers, we can see that the whiskers of the Control and Long-term Krat Exclosure plots are much smaller than the other three plot types.

We have two options here. The first would be to use a non-parametric alternative, such as the Kruskall-Wallis H test. The second would be to use a parametric alternative that is robust to violations of this assumption. The most commonly used is the Welch test.

3. Independence of observations

This assumption states that the data has been collected from random samples and are not related. This is verified through good experimental design. We can state that we have satisfied this assumption.

Performing the ANOVA

```{r}
oneway.test(hindfoot_length ~ plot_type, data = surveys, var.equal = FALSE)
```
According to this ANOVA there is a significant effect of plot type on hindfoot length. 
Now lets explore this effect further by conducting some post-hoc comparisons. We will use a simple bonferroni correction. This can be used to determine our new alpha level, by dividing our original alpha level (.05) by the number of comparisons we will be making (10)

```{r}
pairwise.t.test(surveys$hindfoot_length, surveys$plot_type,
                p.adjust.method = "bonferroni", pool.sd = FALSE)
```