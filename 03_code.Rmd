---
title: "R Code"
---

## Writing better code

We can improve our scripts by writing code which is:

1. Readable

- Use a consistent style guide (like the tidyverse one)
- Be clear, concise, and consistent when naming objects, datasets, and functions
- Break your scripts up into sections (Ctrl+Shift+R)

2. Reusable

- Write functions to perform sets of operations
- Use iteration (for loops, or `map()`) 
- Consider creating packages for data and code used in multiple places
- Break up long scripts into separate files (cleaning, manipulating, plotting)

3. Documented

- Use comments to explain why you did something the way you did 
- Include a README with each project to provide important context and background

Let's take a common example of some data analysis and apply the above principles when writing the code. First make sure our packages are loaded:

```{r}
#| message: false
#| warning: false
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)
```

Let's read in a dataset split into separate files. Instead of reading in each file separately, we can use `readr::read_csv()` to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source. The dataset we're working with contains measurements taken from mammals captured in the Chihuahuan desert. It is split into 4 separate `.csv` files based on time periods the measurements were recorded within. 

```{r}
#| message: false

# Combine data from different collection periods

files <- list.files(path = "data_raw", 
                    pattern = "\\.csv", 
                    full.names = TRUE)

surveys <- read_csv(files, id = "source")
```

Let's take a quick look at the mean `hindfoot_length` and `weight` for each species.

```{r}
surveys |> 
  group_by(species_id) |> 
  summarise(across(c(hindfoot_length, weight), mean, na.rm = TRUE)) |> 
  na.omit()
```

To understand how `hindfoot_length` varies based on the plot type the animal was captured in let's use a boxplot.

```{r}
ggplot(data = surveys, aes(x = plot_type, y = hindfoot_length)) +
  geom_boxplot() +
  theme_bw()
```

Let's say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we're only interested in species codes with at least 100 valid observations, that's still 11 plots.

```{r}
valid_species <-
  surveys |>
  drop_na(all_of(c("weight", "hindfoot_length"))) |> 
  count(species_id) |> 
  filter(n >= 100) |> 
  pull(species_id)
```

Let's first create a basic plot to show what we're trying to produce.

```{r}
#| message: false
#| warning: false
# Create an example of a plot

ggplot(surveys, aes(x = weight, y = hindfoot_length)) +
  geom_point(alpha = 0.2) +
  theme_minimal()
```

Rather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.

```{r}
plot_species <- function(data, x_var, y_var, species) {
  
  # Check that the data contains the species or provide a useful error message
  if (!(species %in% data$species_id)) {
    stop(paste0("Error: Species ID '", species, "' not found in the dataset."))
  }
  
  # Use .data[[]] so we can pass strings as arguments to use in plot titles and save paths
  plots <- 
    data |> 
    filter(species_id == .env$species) |> 
    ggplot(aes(x = .data[[x_var]], 
               y = .data[[y_var]])) +
    geom_point(alpha = 0.2) +
    theme_minimal() +
    ggtitle(paste0(y_var, " vs. ", x_var, " for Species ID: ", species))
  
  ggsave(paste0("figures/", species, "_", x_var, "_vs_", y_var, ".png"), 
         plot = plots, width = 10, height = 6)
}

# purrr::walk iterates over valid_species to create and save the plots

walk(valid_species, ~ plot_species(
  data = surveys,
  x_var = "weight",            
  y_var = "hindfoot_length",   
  species = .x 
))
```
