---
title: "R Code"
---

## Writing better code

We can improve our scripts by writing code which is:

1. Readable

- Use a consistent style guide (like the tidyverse one)
- Be clear, concise, and consistent when naming objects, datasets, and functions
- Break your scripts up into sections (Ctrl+Shift+R)

2. Reusable

- Write functions to perform sets of operations
- Use iteration (for loops, or `map()`) 
- Consider creating packages for data and code used in multiple places
- Break up long scripts into separate files (cleaning, manipulating, plotting)

3. Documented

- Use comments to explain why you did something the way you did 
- Include a README with each project to provide important context and background

Let's take a common example of some data analysis and apply the above principles when writing the code. First make sure our packages are loaded:

```{r}
#| message: false
#| warning: false
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)
```

Let's read in a dataset split into separate files. Instead of reading in each file separately, we can use `readr::read_csv()` to read them all in at once, bind them together into a single dataframe, and add a new column containing the filename of the data source. The dataset we're working with contains measurements taken from mammals captured in the Chihuahuan desert. It is split into 4 separate `.csv` files based on time periods the measurements were recorded within. 

```{r}
#| message: false

# Combine data from different collection periods

files <- list.files(path = "data_raw", 
                    pattern = "\\.csv", 
                    full.names = TRUE)

surveys <- read_csv(files, id = "source")
```

Let's take a quick look at the mean `hindfoot_length` and `weight` for each species.

```{r}
surveys |> 
  group_by(species_id) |> 
  summarise(across(c(hindfoot_length, weight), mean, na.rm = TRUE)) |> 
  na.omit()
```

To understand how `hindfoot_length` varies based on the plot type the animal was captured in let's use a boxplot.

```{r}
ggplot(data = surveys, aes(x = plot_type, y = hindfoot_length)) +
  geom_boxplot() +
  theme_bw()
```

Let's say we wanted to create a separate scatterplot for each species showing hindfoot length vs weight. Even if we're only interested in species codes with at least 100 valid observations, that's still 11 plots.

```{r}
valid_species <-
  surveys |>
  drop_na(all_of(c("weight", "hindfoot_length"))) |> 
  count(species_id) |> 
  filter(n >= 100) |> 
  pull(species_id)
```

Let's first create a basic plot to show what we're trying to produce.

```{r}
#| message: false
#| warning: false
# Create an example of a plot

ggplot(surveys, aes(x = weight, y = hindfoot_length)) +
  geom_point(alpha = 0.2) +
  theme_minimal()
```

Rather than write out the same code 15 times, this is a good time to write our own function. If we encapsulate all the plotting steps in a function, we can then use {purrr} to apply the function over the species and create the plots.

```{r}
plot_species <- function(data, x_var, y_var, species) {
  
  # Check that the data contains the species or provide a useful error message
  if (!(species %in% data$species_id)) {
    stop(paste0("Error: Species ID '", species, "' not found in the dataset."))
  }
  
  # Use .data[[]] so we can pass strings as arguments to use in plot titles and save paths
  plots <- 
    data |> 
    filter(species_id == .env$species) |> 
    ggplot(aes(x = .data[[x_var]], 
               y = .data[[y_var]])) +
    geom_point(alpha = 0.2) +
    theme_minimal() +
    ggtitle(paste0(y_var, " vs. ", x_var, " for Species ID: ", species))
  
  ggsave(paste0("figures/", species, "_", x_var, "_vs_", y_var, ".png"), 
         plot = plots, width = 10, height = 6)
}

# purrr::walk iterates over valid_species to create and save the plots

walk(valid_species, ~ plot_species(
  data = surveys,
  x_var = "weight",            
  y_var = "hindfoot_length",   
  species = .x 
))
```

We have done some preliminary inspecting of our data. Now lets go one step further and liken this to a more realistic workflow. Perhaps we want to look more closely at the plot type. 

In 1977, 24 experimental plots were established and each plot was manipulated in one of five ways. We can look at these plot types using `dplyr::distinct()` 

```{r}
surveys |> distinct(plot_type)
```

Given that these plot types concern excluding other rodents, one question we may want the answer to is how this has impacted on the development of the mammals we are sampling, specifically their hindfoot_length.

As with any questions like this, a good place to start would be to visualise the data.Given that we have a categorical independent variable (plot_type), lets use a boxplot.

```{r}
ggplot(surveys, aes(x = plot_type, y = hindfoot_length)) +
  geom_boxplot() +
  theme_minimal() +
  coord_flip() # Using coord flip to rotate the plot so the labels are easily readable
```
It looks like there may be a relationship between weight and plot type. We can see that, for example, there looks to be quite a difference in weight between the control and the long-term krat exclosure plot-types.

Because we have a continuous dependent variable (weight) and an categorical independent variable (plot type), with multiple levels, ANOVA would be an appropriate statistical test with some post-hoc comparisons to test the individual differences in weight across each plot type.

Before we do that though, there are a number of assumptions we must check:

1. Normality

As with any general linear model, we must check for normality. Here, we are looking at normality of residuals. In truth, because our sample size per group is so high, I usually wouldn't bother inspecting this, but I will here.

There are two main ways of testing this assumption, graphical and statistical. We recommend the graphical methods, which include plotting the residuals in a histogram or QQ-plot. The statistical methods include normality tests such as Shapiro-Wilk which can be rather conservative, especially given large sample sizes. 

Here we will plot the residuals using a histogram and QQ-plot.

```{r}
# Run the ANOVA to get our residuals
residuals_anova <- aov(hindfoot_length ~ plot_type, data = surveys)

# Create plot space
par(mfrow = c(1, 2))

# Create histogram
hist(residuals_anova$residuals)

# Create QQ-plot
qqPlot(residuals_anova$residuals, id = FALSE)
```

We can see that the residuals do not exactly follow a normal distribution. In this case, I would be ok with this as combined with our large sample size our ANOVA will be fairly robust to any violation of normality.

2. Homogeneity - Equality of Variances

Our second assumption to check is whether the variance in hindfoot length is roughly equal across all plot types. We can do this, again, using statistical methods, graphical methods, or both. Just like normality, I will opt for graphical methods. In particular, I will once again use a boxplot.

```{r}
ggplot(surveys, aes(x = plot_type, y = hindfoot_length)) +
  geom_boxplot(outliers = FALSE) +
  theme_minimal() +
  coord_flip() # Using coord flip to rotate the plot so the labels are easily readable
```
It seems quite clear that this assumption has been violated. Having removed the outliers, we can see that the whiskers of the Control and Long-term Krat Exclosure plots are much smaller than the other three plot types. If the groups had similar sample sizes I would not be too worried, but they do not.

We have two options here. The first would be to use a non-parametric alternative, such as the Kruskall-Wallis H test. The second would be to use a parametric alternative that is robust to violations of this assumption. The most commonly used is the Welch test.

3. Independence of observations

This assumption states that the data has been collected from random sample and are not related. This is verified through good experimental design. We can state that we have satisfied this assumption.

### Performing the ANOVA

```{r}
oneway.test(hindfoot_length ~ plot_type, data = surveys, var.equal = FALSE)
```
According to this ANOVA there is a significant effect of plot type on hindfoot length. 
Now lets explore this effect further by conducting some post-hoc comparisons. We will use a simple bonferroni correction. This can be used to determine our new alpha level, by dividing our original alpha level (.05) by the number of comparisons we will be making (10)

```{r}
pairwise.t.test(surveys$hindfoot_length, surveys$plot_type,
                p.adjust.method = "bonferroni", pool.sd = FALSE)
```

Done, but i don't actually like this too much. 
